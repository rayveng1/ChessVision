[{"/Users/connorscally/Documents/GitHub/ChessVision/chessvision_frontend/src/index.js":"1","/Users/connorscally/Documents/GitHub/ChessVision/chessvision_frontend/src/App.js":"2","/Users/connorscally/Documents/GitHub/ChessVision/chessvision_frontend/src/reportWebVitals.js":"3","/Users/connorscally/Documents/GitHub/ChessVision/chessvision_frontend/src/components/roboflow.js":"4","/Users/connorscally/Documents/GitHub/ChessVision/chessvision_frontend/src/pages/Results.js":"5","/Users/connorscally/Documents/GitHub/ChessVision/chessvision_frontend/src/pages/Confirm.js":"6","/Users/connorscally/Documents/GitHub/ChessVision/chessvision_frontend/src/components/Navbar/index.js":"7","/Users/connorscally/Documents/GitHub/ChessVision/chessvision_frontend/src/components/Navbar/NavbarElements.js":"8","/Users/connorscally/Documents/GitHub/ChessVision/chessvision_frontend/src/pages/Main.js":"9"},{"size":535,"mtime":1682562354064,"results":"10","hashOfConfig":"11"},{"size":639,"mtime":1682565541803,"results":"12","hashOfConfig":"11"},{"size":362,"mtime":1682562354064,"results":"13","hashOfConfig":"11"},{"size":4893,"mtime":1682562530200,"results":"14","hashOfConfig":"11"},{"size":162,"mtime":1682567866157,"results":"15","hashOfConfig":"11"},{"size":162,"mtime":1682563041303,"results":"16","hashOfConfig":"11"},{"size":378,"mtime":1682565175594,"results":"17","hashOfConfig":"11"},{"size":997,"mtime":1682564144061,"results":"18","hashOfConfig":"11"},{"size":327,"mtime":1682565733599,"results":"19","hashOfConfig":"11"},{"filePath":"20","messages":"21","suppressedMessages":"22","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"23"},"1ht3utt",{"filePath":"24","messages":"25","suppressedMessages":"26","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"23"},{"filePath":"27","messages":"28","suppressedMessages":"29","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"23"},{"filePath":"30","messages":"31","suppressedMessages":"32","errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"33","usedDeprecatedRules":"23"},{"filePath":"34","messages":"35","suppressedMessages":"36","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"37","messages":"38","suppressedMessages":"39","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"23"},{"filePath":"40","messages":"41","suppressedMessages":"42","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"23"},{"filePath":"43","messages":"44","suppressedMessages":"45","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"23"},{"filePath":"46","messages":"47","suppressedMessages":"48","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"23"},"/Users/connorscally/Documents/GitHub/ChessVision/chessvision_frontend/src/index.js",[],[],[],"/Users/connorscally/Documents/GitHub/ChessVision/chessvision_frontend/src/App.js",[],[],"/Users/connorscally/Documents/GitHub/ChessVision/chessvision_frontend/src/reportWebVitals.js",[],[],"/Users/connorscally/Documents/GitHub/ChessVision/chessvision_frontend/src/components/roboflow.js",["49","50"],[],"import { useRef, useEffect } from \"react\";\nimport Webcam from \"react-webcam\";\n\nconst Roboflow = (props) => {\n    const webcamRef = useRef(null);\n    const canvasRef = useRef(null);\n    var inferRunning;\n    var model;\n\n    const startInfer = () => {\n        inferRunning = true;\n        window.roboflow\n            .auth({\n                publishable_key: \"rf_WBRxGv13UGfWTZ0T4sZYv1ZBA3p1\"\n            })\n            .load({\n                model: props.modelName,\n                version: props.modelVersion,\n                onMetadata: function (m) {\n                    console.log(\"model loaded\");\n                }\n            }).then((model) => {\n                setInterval(() => {\n                    if (inferRunning) detect(model);\n                }, 10);\n            });\n    };\n\n    useEffect(startInfer, []);\n\n    // const stopInfer = () => {\n    //     inferRunning = false;\n    //     if (model) model.teardown();\n    // };\n\n    const detect = async (model) => {\n        // Check data is available\n        if (\n            typeof webcamRef.current !== \"undefined\" &&\n            webcamRef.current !== null &&\n            webcamRef.current.video.readyState === 4\n        ) {\n            const videoWidth = webcamRef.current.video.videoWidth;\n            const videoHeight = webcamRef.current.video.videoHeight;\n\n            webcamRef.current.video.width = videoWidth;\n            webcamRef.current.video.height = videoHeight;\n\n            adjustCanvas(videoWidth, videoHeight);\n\n            const detections = await model.detect(webcamRef.current.video);\n\n            const ctx = canvasRef.current.getContext(\"2d\");\n            drawBoxes(detections, ctx);\n        }\n    };\n\n    const adjustCanvas = (w, h) => {\n        canvasRef.current.width = w * window.devicePixelRatio;\n        canvasRef.current.height = h * window.devicePixelRatio;\n\n        canvasRef.current.style.width = w + \"px\";\n        canvasRef.current.style.height = h + \"px\";\n\n        canvasRef.current.getContext(\"2d\").scale(window.devicePixelRatio, window.devicePixelRatio);\n    };\n\n    const drawBoxes = (detections, ctx) => {\n        ctx.clearRect(0, 0, canvasRef.current.width, canvasRef.current.height);\n        detections.forEach((row) => {\n            if (true) {\n                //video\n                var temp = row.bbox;\n                temp.class = row.class;\n                temp.color = row.color;\n                temp.confidence = row.confidence;\n                row = temp;\n            }\n\n            if (row.confidence < 0) return;\n\n            //dimensions\n            var x = row.x - row.width / 2;\n            var y = row.y - row.height / 2;\n            var w = row.width;\n            var h = row.height;\n\n            //box\n            ctx.beginPath();\n            ctx.lineWidth = 1;\n            ctx.strokeStyle = row.color;\n            ctx.rect(x, y, w, h);\n            ctx.stroke();\n\n            //shade\n            ctx.fillStyle = \"black\";\n            ctx.globalAlpha = 0.2;\n            ctx.fillRect(x, y, w, h);\n            ctx.globalAlpha = 1.0;\n\n            //label\n            var fontColor = \"black\";\n            var fontSize = 12;\n            ctx.font = `${fontSize}px monospace`;\n            ctx.textAlign = \"center\";\n            var classTxt = row.class;\n            var confTxt = (row.confidence * 100).toFixed().toString() + \"%\";\n            var msgTxt = classTxt + \" \" + confTxt;\n            const textHeight = fontSize;\n            var textWidth = ctx.measureText(msgTxt).width;\n\n            if (textHeight <= h && textWidth <= w) {\n                ctx.strokeStyle = row.color;\n                ctx.fillStyle = row.color;\n                ctx.fillRect(\n                    x - ctx.lineWidth / 2,\n                    y - textHeight - ctx.lineWidth,\n                    textWidth + 2,\n                    textHeight + 1\n                );\n                ctx.stroke();\n                ctx.fillStyle = fontColor;\n                ctx.fillText(msgTxt, x + textWidth / 2 + 1, y - 1);\n            } else {\n                textWidth = ctx.measureText(confTxt).width;\n                ctx.strokeStyle = row.color;\n                ctx.fillStyle = row.color;\n                ctx.fillRect(\n                    x - ctx.lineWidth / 2,\n                    y - textHeight - ctx.lineWidth,\n                    textWidth + 2,\n                    textHeight + 1\n                );\n                ctx.stroke();\n                ctx.fillStyle = fontColor;\n                ctx.fillText(confTxt, x + textWidth / 2 + 1, y - 1);\n            }\n        });\n    };\n\n    return (\n        <>\n            <Webcam\n                ref={webcamRef}\n                muted={true}\n                className=\"absolute mx-auto left-0 right-0 text-center z-10\"\n            />\n            <canvas ref={canvasRef} className=\"absolute mx-auto left-0 right-0 text-center z-20\" />\n        </>\n    );\n};\n\nexport default Roboflow;\n","/Users/connorscally/Documents/GitHub/ChessVision/chessvision_frontend/src/pages/Results.js",[],[],"/Users/connorscally/Documents/GitHub/ChessVision/chessvision_frontend/src/pages/Confirm.js",[],[],"/Users/connorscally/Documents/GitHub/ChessVision/chessvision_frontend/src/components/Navbar/index.js",[],[],"/Users/connorscally/Documents/GitHub/ChessVision/chessvision_frontend/src/components/Navbar/NavbarElements.js",[],[],"/Users/connorscally/Documents/GitHub/ChessVision/chessvision_frontend/src/pages/Main.js",[],[],{"ruleId":"51","severity":1,"message":"52","line":8,"column":9,"nodeType":"53","messageId":"54","endLine":8,"endColumn":14},{"ruleId":"55","severity":1,"message":"56","line":11,"column":24,"nodeType":"57","endLine":11,"endColumn":28},"no-unused-vars","'model' is defined but never used.","Identifier","unusedVar","react-hooks/exhaustive-deps","Assignments to the 'inferRunning' variable from inside React Hook useEffect will be lost after each render. To preserve the value over time, store it in a useRef Hook and keep the mutable value in the '.current' property. Otherwise, you can move this variable directly inside useEffect.","Literal"]